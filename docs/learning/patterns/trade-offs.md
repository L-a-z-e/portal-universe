# 아키텍처 트레이드오프 분석

## 학습 목표
- 아키텍처 결정의 트레이드오프 이해
- Portal Universe의 기술 선택 근거 학습
- 상황별 최적 결정 기준 파악

---

## 1. 트레이드오프란?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      ARCHITECTURE TRADE-OFFS                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   "은탄환은 없다" - Fred Brooks                                              │
│                                                                              │
│   모든 아키텍처 결정은 트레이드오프를 수반합니다:                            │
│                                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                                                                      │   │
│   │   성능 ◄───────────────────────────────────────────────► 유지보수성 │   │
│   │                                                                      │   │
│   │   일관성 ◄─────────────────────────────────────────────► 가용성     │   │
│   │                                                                      │   │
│   │   단순성 ◄─────────────────────────────────────────────► 유연성     │   │
│   │                                                                      │   │
│   │   개발 속도 ◄───────────────────────────────────────────► 안정성    │   │
│   │                                                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│   핵심: 무엇을 포기할 것인가를 명확히 결정하는 것                            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 모놀리스 vs 마이크로서비스

### 2.1 Portal Universe 선택: 마이크로서비스

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    MONOLITH VS MICROSERVICES                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   모놀리스                         마이크로서비스 (선택)                     │
│   ┌────────────────┐               ┌────────────────┐                        │
│   │                │               │     Auth       │                        │
│   │    단일 앱     │               ├────────────────┤                        │
│   │                │               │   Shopping     │                        │
│   │  Auth + Shop   │               ├────────────────┤                        │
│   │  + Blog        │               │     Blog       │                        │
│   │                │               ├────────────────┤                        │
│   │                │               │  Notification  │                        │
│   └────────────────┘               └────────────────┘                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 트레이드오프 분석

| 관점 | 모놀리스 | 마이크로서비스 | Portal Universe 결정 |
|------|----------|---------------|----------------------|
| **배포** | 전체 재배포 | 독립 배포 | ✓ 서비스별 독립 배포 |
| **확장** | 전체 스케일링 | 서비스별 스케일링 | ✓ Shopping만 스케일 아웃 가능 |
| **복잡성** | 낮음 | 높음 (분산 시스템) | △ 학습 곡선 필요 |
| **데이터** | 단일 DB | Polyglot | ✓ 서비스별 최적 DB |
| **일관성** | 강한 일관성 | 최종 일관성 | △ Saga 패턴 필요 |
| **운영** | 단순 | 복잡 (K8s, 모니터링) | △ 운영 오버헤드 |

### 2.3 선택 근거

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      WHY MICROSERVICES?                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   1. 학습 목적                                                               │
│      • 분산 시스템 패턴 학습 (Saga, Circuit Breaker, Event-Driven)          │
│      • 실제 엔터프라이즈 환경 시뮬레이션                                     │
│                                                                              │
│   2. 기술 다양성                                                             │
│      • Shopping: MySQL + Elasticsearch (복잡한 쿼리, 검색)                  │
│      • Blog: MongoDB (Document 모델, 유연한 스키마)                          │
│      • 프론트: Vue + React 공존 (Module Federation)                          │
│                                                                              │
│   3. 확장성                                                                  │
│      • 타임딜 트래픽 → Shopping Service만 스케일 아웃                        │
│      • 서비스별 리소스 최적화                                                │
│                                                                              │
│   포기한 것:                                                                 │
│   • 단순한 배포/운영                                                         │
│   • 강한 트랜잭션 일관성                                                     │
│   • 낮은 네트워크 지연                                                       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 3. 동기 vs 비동기 통신

### 3.1 Portal Universe 선택: 하이브리드

| 시나리오 | 선택 | 이유 |
|----------|------|------|
| 사용자 인증 조회 | REST (동기) | 즉시 응답 필요 |
| 주문 생성 알림 | Kafka (비동기) | 느슨한 결합, 장애 격리 |
| 결제 처리 | REST (동기) | 트랜잭션 보장 |
| 배송 시작 알림 | Kafka (비동기) | 비핵심 경로 |

### 3.2 트레이드오프

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    SYNC VS ASYNC COMMUNICATION                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   동기 (REST/gRPC)                                                           │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │ ✓ 즉각적인 응답                                                     │   │
│   │ ✓ 간단한 에러 처리                                                   │   │
│   │ ✓ 디버깅 용이                                                        │   │
│   │ ✗ 강한 결합                                                          │   │
│   │ ✗ 연쇄 장애 위험                                                     │   │
│   │ ✗ 호출 서비스 다운 시 실패                                           │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│   비동기 (Kafka)                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │ ✓ 느슨한 결합                                                        │   │
│   │ ✓ 장애 격리 (Consumer 다운해도 메시지 유지)                          │   │
│   │ ✓ 부하 평준화                                                        │   │
│   │ ✗ 최종 일관성 (지연 발생)                                            │   │
│   │ ✗ 복잡한 에러 처리 (DLQ)                                             │   │
│   │ ✗ 디버깅 어려움 (이벤트 추적)                                        │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. 데이터베이스 선택

### 4.1 Shopping Service: MySQL

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    SHOPPING SERVICE: MySQL                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   선택 이유:                                                                 │
│   • 주문-결제-재고 간 복잡한 관계                                            │
│   • ACID 트랜잭션 필요 (재고 차감)                                           │
│   • 집계 쿼리 (매출 통계, 재고 현황)                                         │
│                                                                              │
│   포기한 것:                                                                 │
│   • 스키마 유연성 (마이그레이션 필요)                                        │
│   • 수평 확장의 어려움                                                       │
│                                                                              │
│   보완:                                                                      │
│   • Elasticsearch: 상품 검색, 자동완성                                       │
│   • Redis: 세션, 분산 락, 캐싱                                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 Blog Service: MongoDB

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      BLOG SERVICE: MongoDB                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   선택 이유:                                                                 │
│   • 포스트 = 자연스러운 Document                                             │
│   • 댓글, 태그 임베딩으로 조인 최소화                                        │
│   • 유연한 스키마 (필드 추가 용이)                                           │
│                                                                              │
│   포기한 것:                                                                 │
│   • 복잡한 조인 쿼리                                                         │
│   • 강한 트랜잭션 (Multi-Document)                                           │
│                                                                              │
│   설계 결정:                                                                 │
│   • 작성자 정보: Embedding (읽기 최적화)                                     │
│   • 댓글: Reference (무한 중첩 방지)                                         │
│   • 태그: Embedding (포스트와 함께 조회)                                     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.3 비교 매트릭스

| 요구사항 | MySQL 적합 | MongoDB 적합 |
|----------|:----------:|:------------:|
| 복잡한 관계 | ✓ | △ |
| ACID 트랜잭션 | ✓ | △ |
| 유연한 스키마 | △ | ✓ |
| 수평 확장 | △ | ✓ |
| 임베딩 데이터 | ✗ | ✓ |
| 집계 쿼리 | ✓ | ✓ |

---

## 5. 상태 관리 전략

### 5.1 Saga vs 2PC

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        SAGA VS 2PC                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   2PC (Two-Phase Commit)                                                     │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │ Phase 1: Prepare                                                     │   │
│   │ Coordinator ───► All Participants: "준비됐나요?"                     │   │
│   │                                                                      │   │
│   │ Phase 2: Commit                                                      │   │
│   │ Coordinator ───► All Participants: "커밋하세요!"                     │   │
│   │                                                                      │   │
│   │ ✗ 분산 환경에서 성능 저하                                            │   │
│   │ ✗ 락 유지 시간이 길어 데드락 위험                                    │   │
│   │ ✗ Coordinator SPOF                                                   │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│   Saga (Portal Universe 선택)                                               │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │ 각 단계: 로컬 트랜잭션 커밋                                          │   │
│   │ 실패 시: 보상 트랜잭션 실행                                          │   │
│   │                                                                      │   │
│   │ ✓ 긴 락 없음                                                         │   │
│   │ ✓ 서비스 독립성 유지                                                 │   │
│   │ △ 최종 일관성 (일시적 불일치 허용)                                   │   │
│   │ △ 보상 로직 복잡                                                     │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.2 Orchestration vs Choreography

| 관점 | Orchestration (선택) | Choreography |
|------|:--------------------:|:------------:|
| 흐름 파악 | ✓ 한 곳에서 관리 | △ 이벤트 추적 필요 |
| 결합도 | △ Orchestrator 의존 | ✓ 낮음 |
| 디버깅 | ✓ 쉬움 | △ 어려움 |
| 확장성 | △ Orchestrator 병목 | ✓ 높음 |
| 복잡도 | ✓ 보상 로직 명확 | △ 분산된 보상 |

**선택 근거**: 주문 흐름이 명확하고, 보상 로직 관리가 중요하여 Orchestration 선택

---

## 6. 프론트엔드 아키텍처

### 6.1 Module Federation vs 모놀리스 SPA

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    MODULE FEDERATION TRADE-OFFS                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   모놀리스 SPA                     Module Federation (선택)                  │
│   ┌────────────────────┐          ┌────────────────────────────────────┐    │
│   │                    │          │  Portal Shell (Host)               │    │
│   │   단일 번들        │          │       ▼                            │    │
│   │   단일 팀          │          │  ┌─────────┐  ┌─────────┐          │    │
│   │   단일 기술 스택    │          │  │Shopping │  │  Blog   │          │    │
│   │                    │          │  │ (React) │  │ (Vue)   │          │    │
│   └────────────────────┘          │  └─────────┘  └─────────┘          │    │
│                                   └────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 트레이드오프

| 관점 | 모놀리스 SPA | Module Federation |
|------|:------------:|:-----------------:|
| 초기 로드 | ✗ 전체 번들 | ✓ 필요한 모듈만 |
| 배포 | ✗ 전체 재배포 | ✓ 독립 배포 |
| 기술 스택 | ✗ 단일 | ✓ 다양 (Vue + React) |
| 복잡성 | ✓ 낮음 | △ 버전 관리 |
| 상태 공유 | ✓ 쉬움 | △ 명시적 공유 필요 |

**선택 근거**:
- 학습 목적: Vue와 React 동시 학습
- 독립 배포: 서비스별 독립적인 배포 사이클
- 확장성: 새 서비스 추가 용이

---

## 7. 캐싱 전략

### 7.1 Cache-Aside vs Write-Through

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        CACHING STRATEGIES                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Cache-Aside (Portal Universe 사용)                                        │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  1. App이 Cache 조회                                                 │   │
│   │  2. Cache Miss → DB 조회                                             │   │
│   │  3. App이 Cache에 저장                                               │   │
│   │                                                                      │   │
│   │  ✓ 읽기 최적화                                                       │   │
│   │  ✓ Cache 장애 시에도 DB에서 조회 가능                                │   │
│   │  △ Cache와 DB 불일치 가능 (TTL로 해결)                               │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│   Write-Through                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  1. App이 Cache에 쓰기                                               │   │
│   │  2. Cache가 DB에 동기 쓰기                                           │   │
│   │                                                                      │   │
│   │  ✓ 항상 일관성 보장                                                  │   │
│   │  ✗ 쓰기 지연 증가                                                    │   │
│   │  ✗ Cache 장애 시 쓰기 실패                                           │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 7.2 적용 예시

| 데이터 | 전략 | TTL | 이유 |
|--------|------|-----|------|
| 상품 상세 | Cache-Aside | 5분 | 읽기 빈번, 변경 적음 |
| 장바구니 | 캐시 안함 | - | 실시간 정확성 필요 |
| 재고 수량 | 캐시 안함 | - | 정확성 필수 |
| 카테고리 목록 | Cache-Aside | 1시간 | 거의 변경 없음 |

---

## 8. 보안 트레이드오프

### 8.1 JWT vs Session

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        JWT VS SESSION                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Session                          JWT (선택)                                │
│   ┌────────────────────┐          ┌────────────────────────────────────┐    │
│   │ Server             │          │ Stateless                          │    │
│   │ ┌──────────────┐   │          │ • 서버 확장 용이                   │    │
│   │ │ Session Store│   │          │ • 마이크로서비스 환경 적합          │    │
│   │ │   (Redis)    │   │          │                                    │    │
│   │ └──────────────┘   │          │ Token (Access + Refresh)           │    │
│   │                    │          │ • Access: 15분                     │    │
│   │ • 즉시 무효화 가능 │          │ • Refresh: 7일 (Redis 저장)        │    │
│   │ • 서버 상태 의존   │          │                                    │    │
│   └────────────────────┘          └────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 8.2 트레이드오프

| 관점 | Session | JWT |
|------|:-------:|:---:|
| 확장성 | △ Session 공유 필요 | ✓ Stateless |
| 즉시 무효화 | ✓ 세션 삭제 | △ Blacklist 필요 |
| 페이로드 크기 | ✓ 작음 | △ 큼 |
| MSA 호환 | △ | ✓ |

**Portal Universe 결정**: JWT + Redis Refresh Token 조합
- 장점: Stateless API 서버, 확장 용이
- 단점: 로그아웃 시 블랙리스트 필요 (Redis 활용)

---

## 9. 핵심 정리

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    KEY TRADE-OFF DECISIONS                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   아키텍처:                                                                  │
│   • 마이크로서비스 ← 복잡성 증가를 감수하고 독립성/확장성 획득               │
│                                                                              │
│   통신:                                                                      │
│   • 하이브리드 ← 핵심 경로는 동기, 비핵심은 비동기                           │
│                                                                              │
│   데이터:                                                                    │
│   • Polyglot ← 서비스별 최적 DB, 일관성 관리 복잡도 증가                     │
│                                                                              │
│   트랜잭션:                                                                  │
│   • Saga ← 최종 일관성 허용, 긴 락 회피                                      │
│                                                                              │
│   프론트엔드:                                                                │
│   • Module Federation ← 독립 배포, 상태 공유 복잡도 증가                     │
│                                                                              │
│   인증:                                                                      │
│   • JWT ← Stateless, 즉시 무효화는 Blacklist로 보완                          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 10. 결정 프레임워크

### 기술 선택 시 고려 사항

1. **비즈니스 요구사항**: 무엇을 달성해야 하는가?
2. **팀 역량**: 팀이 기술을 운영할 수 있는가?
3. **확장 계획**: 향후 어떻게 성장할 것인가?
4. **운영 복잡성**: 운영 비용이 감당 가능한가?
5. **포기하는 것**: 무엇을 희생하는지 명확한가?

---

## 다음 학습

- [SOLID 원칙](./solid-principles.md)
- [레이어드 아키텍처](./layered-architecture.md)
- [Portal Universe 패턴 총정리](../patterns/portal-universe-patterns.md)
